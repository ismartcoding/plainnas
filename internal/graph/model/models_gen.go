// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type FileInfoData interface {
	IsFileInfoData()
}

type App struct {
	URLToken     string           `json:"urlToken"`
	HTTPPort     int              `json:"httpPort"`
	HTTPSPort    int              `json:"httpsPort"`
	Audios       []*PlaylistAudio `json:"audios"`
	AudioCurrent string           `json:"audioCurrent"`
	AudioMode    string           `json:"audioMode"`
	DataDir      string           `json:"dataDir"`
	ScanProgress *ScanProgress    `json:"scanProgress"`
}

type AppUpdate struct {
	CurrentVersion string  `json:"currentVersion"`
	LatestVersion  *string `json:"latestVersion,omitempty"`
	HasUpdate      bool    `json:"hasUpdate"`
	URL            *string `json:"url,omitempty"`
}

type Audio struct {
	ID          string    `json:"id"`
	Title       string    `json:"title"`
	Artist      string    `json:"artist"`
	Path        string    `json:"path"`
	Duration    int       `json:"duration"`
	Size        int64     `json:"size"`
	BucketID    string    `json:"bucketId"`
	AlbumFileID string    `json:"albumFileId"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
	Tags        []*Tag    `json:"tags"`
}

type AudioFileInfo struct {
	Duration *int         `json:"duration,omitempty"`
	Location *GeoLocation `json:"location,omitempty"`
}

func (AudioFileInfo) IsFileInfoData() {}

type DeviceInfo struct {
	Hostname         string     `json:"hostname"`
	Os               string     `json:"os"`
	KernelVersion    string     `json:"kernelVersion"`
	AppVersion       string     `json:"appVersion"`
	AppFullVersion   string     `json:"appFullVersion"`
	Arch             string     `json:"arch"`
	Uptime           int64      `json:"uptime"`
	BootTime         int64      `json:"bootTime"`
	CPUModel         string     `json:"cpuModel"`
	CPUCores         int        `json:"cpuCores"`
	CPUThreads       int        `json:"cpuThreads"`
	Load1            float64    `json:"load1"`
	Load5            float64    `json:"load5"`
	Load15           float64    `json:"load15"`
	MemoryTotalBytes int64      `json:"memoryTotalBytes"`
	MemoryFreeBytes  int64      `json:"memoryFreeBytes"`
	SwapTotalBytes   int64      `json:"swapTotalBytes"`
	SwapFreeBytes    int64      `json:"swapFreeBytes"`
	SwapUsedBytes    int64      `json:"swapUsedBytes"`
	Ips              []string   `json:"ips"`
	Nics             []*NicInfo `json:"nics"`
	Model            string     `json:"model"`
}

type Event struct {
	ID        string    `json:"id"`
	Type      string    `json:"type"`
	Message   string    `json:"message"`
	ClientID  string    `json:"clientId"`
	CreatedAt time.Time `json:"createdAt"`
}

type FavoriteFolder struct {
	RootPath     string  `json:"rootPath"`
	RelativePath string  `json:"relativePath"`
	Alias        *string `json:"alias,omitempty"`
}

type File struct {
	Path       string    `json:"path"`
	IsDir      bool      `json:"isDir"`
	CreatedAt  time.Time `json:"createdAt"`
	UpdatedAt  time.Time `json:"updatedAt"`
	Size       int64     `json:"size"`
	ChildCount int       `json:"childCount"`
}

// Detailed info for a single media file used by the lightbox UI.
type FileInfo struct {
	Path      string       `json:"path"`
	UpdatedAt time.Time    `json:"updatedAt"`
	Size      int64        `json:"size"`
	Tags      []*Tag       `json:"tags"`
	Data      FileInfoData `json:"data,omitempty"`
}

type FileTask struct {
	ID         string         `json:"id"`
	Type       FileTaskType   `json:"type"`
	Title      string         `json:"title"`
	Status     FileTaskStatus `json:"status"`
	Error      string         `json:"error"`
	TotalBytes int            `json:"totalBytes"`
	DoneBytes  int            `json:"doneBytes"`
	TotalItems int            `json:"totalItems"`
	DoneItems  int            `json:"doneItems"`
	CreatedAt  time.Time      `json:"createdAt"`
	UpdatedAt  time.Time      `json:"updatedAt"`
}

type FileTaskOpInput struct {
	Src       string `json:"src"`
	Dst       string `json:"dst"`
	Overwrite bool   `json:"overwrite"`
}

type GeoLocation struct {
	Latitude  *float64 `json:"latitude,omitempty"`
	Longitude *float64 `json:"longitude,omitempty"`
}

type Image struct {
	ID        string    `json:"id"`
	Title     string    `json:"title"`
	Path      string    `json:"path"`
	Size      int64     `json:"size"`
	BucketID  string    `json:"bucketId"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	Tags      []*Tag    `json:"tags"`
}

type ImageFileInfo struct {
	Width    *int         `json:"width,omitempty"`
	Height   *int         `json:"height,omitempty"`
	Location *GeoLocation `json:"location,omitempty"`
}

func (ImageFileInfo) IsFileInfoData() {}

type MediaActionResult struct {
	Type  DataType `json:"type"`
	Query string   `json:"query"`
}

type MediaBucket struct {
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	ItemCount int      `json:"itemCount"`
	TopItems  []string `json:"topItems"`
}

type Mutation struct {
}

type NicInfo struct {
	Name      string `json:"name"`
	Mac       string `json:"mac"`
	SpeedRate int64  `json:"speedRate"`
}

type PathStat struct {
	Exists bool `json:"exists"`
	IsDir  bool `json:"isDir"`
}

type PathStatResult struct {
	Path   string `json:"path"`
	Exists bool   `json:"exists"`
	IsDir  bool   `json:"isDir"`
}

type PlaylistAudio struct {
	Title    string `json:"title"`
	Artist   string `json:"artist"`
	Path     string `json:"path"`
	Duration int    `json:"duration"`
}

type Query struct {
}

type SambaSettings struct {
	Enabled        bool          `json:"enabled"`
	Username       string        `json:"username"`
	HasPassword    bool          `json:"hasPassword"`
	Shares         []*SambaShare `json:"shares"`
	ServiceName    string        `json:"serviceName"`
	ServiceActive  bool          `json:"serviceActive"`
	ServiceEnabled bool          `json:"serviceEnabled"`
}

type SambaSettingsInput struct {
	Enabled bool               `json:"enabled"`
	Shares  []*SambaShareInput `json:"shares"`
}

type SambaShare struct {
	Name      string         `json:"name"`
	SharePath string         `json:"sharePath"`
	Auth      SambaShareAuth `json:"auth"`
	ReadOnly  bool           `json:"readOnly"`
}

type SambaShareInput struct {
	Name      string         `json:"name"`
	SharePath string         `json:"sharePath"`
	Auth      SambaShareAuth `json:"auth"`
	ReadOnly  bool           `json:"readOnly"`
}

type ScanProgress struct {
	Indexed int64  `json:"indexed"`
	Pending int64  `json:"pending"`
	Total   int64  `json:"total"`
	State   string `json:"state"`
}

type Session struct {
	ClientID   string    `json:"clientId"`
	ClientName string    `json:"clientName"`
	LastActive time.Time `json:"lastActive"`
	CreatedAt  time.Time `json:"createdAt"`
	UpdatedAt  time.Time `json:"updatedAt"`
}

type StorageDisk struct {
	Name      string  `json:"name"`
	Path      string  `json:"path"`
	SizeBytes int64   `json:"sizeBytes"`
	Removable bool    `json:"removable"`
	Model     *string `json:"model,omitempty"`
}

type StorageMount struct {
	ID           string  `json:"id"`
	Name         string  `json:"name"`
	Path         *string `json:"path,omitempty"`
	PartitionNum *int    `json:"partitionNum,omitempty"`
	Label        *string `json:"label,omitempty"`
	UUID         *string `json:"uuid,omitempty"`
	MountPoint   *string `json:"mountPoint,omitempty"`
	FsType       *string `json:"fsType,omitempty"`
	TotalBytes   int64   `json:"totalBytes"`
	UsedBytes    *int64  `json:"usedBytes,omitempty"`
	FreeBytes    *int64  `json:"freeBytes,omitempty"`
	Alias        *string `json:"alias,omitempty"`
	Remote       bool    `json:"remote"`
	DriveType    *string `json:"driveType,omitempty"`
	ParentDevice *string `json:"parentDevice,omitempty"`
}

type Tag struct {
	ID    string `json:"id"`
	Name  string `json:"name"`
	Type  int    `json:"type"`
	Count int    `json:"count"`
}

type TagRelationStub struct {
	Key   string `json:"key"`
	Title string `json:"title"`
	Size  int64  `json:"size"`
}

type TempValue struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type Video struct {
	ID        string    `json:"id"`
	Title     string    `json:"title"`
	Path      string    `json:"path"`
	Duration  int       `json:"duration"`
	Size      int64     `json:"size"`
	BucketID  string    `json:"bucketId"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	Tags      []*Tag    `json:"tags"`
}

type VideoFileInfo struct {
	Duration *int         `json:"duration,omitempty"`
	Width    *int         `json:"width,omitempty"`
	Height   *int         `json:"height,omitempty"`
	Location *GeoLocation `json:"location,omitempty"`
}

func (VideoFileInfo) IsFileInfoData() {}

type DataType string

const (
	DataTypeDefault DataType = "DEFAULT"
	DataTypeAudio   DataType = "AUDIO"
	DataTypeVideo   DataType = "VIDEO"
	DataTypeImage   DataType = "IMAGE"
)

var AllDataType = []DataType{
	DataTypeDefault,
	DataTypeAudio,
	DataTypeVideo,
	DataTypeImage,
}

func (e DataType) IsValid() bool {
	switch e {
	case DataTypeDefault, DataTypeAudio, DataTypeVideo, DataTypeImage:
		return true
	}
	return false
}

func (e DataType) String() string {
	return string(e)
}

func (e *DataType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DataType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DataType", str)
	}
	return nil
}

func (e DataType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FileSortBy string

const (
	FileSortByDateAsc  FileSortBy = "DATE_ASC"
	FileSortByDateDesc FileSortBy = "DATE_DESC"
	FileSortBySizeAsc  FileSortBy = "SIZE_ASC"
	FileSortBySizeDesc FileSortBy = "SIZE_DESC"
	FileSortByNameAsc  FileSortBy = "NAME_ASC"
	FileSortByNameDesc FileSortBy = "NAME_DESC"
)

var AllFileSortBy = []FileSortBy{
	FileSortByDateAsc,
	FileSortByDateDesc,
	FileSortBySizeAsc,
	FileSortBySizeDesc,
	FileSortByNameAsc,
	FileSortByNameDesc,
}

func (e FileSortBy) IsValid() bool {
	switch e {
	case FileSortByDateAsc, FileSortByDateDesc, FileSortBySizeAsc, FileSortBySizeDesc, FileSortByNameAsc, FileSortByNameDesc:
		return true
	}
	return false
}

func (e FileSortBy) String() string {
	return string(e)
}

func (e *FileSortBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FileSortBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FileSortBy", str)
	}
	return nil
}

func (e FileSortBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FileTaskStatus string

const (
	FileTaskStatusQueued  FileTaskStatus = "QUEUED"
	FileTaskStatusRunning FileTaskStatus = "RUNNING"
	FileTaskStatusDone    FileTaskStatus = "DONE"
	FileTaskStatusError   FileTaskStatus = "ERROR"
)

var AllFileTaskStatus = []FileTaskStatus{
	FileTaskStatusQueued,
	FileTaskStatusRunning,
	FileTaskStatusDone,
	FileTaskStatusError,
}

func (e FileTaskStatus) IsValid() bool {
	switch e {
	case FileTaskStatusQueued, FileTaskStatusRunning, FileTaskStatusDone, FileTaskStatusError:
		return true
	}
	return false
}

func (e FileTaskStatus) String() string {
	return string(e)
}

func (e *FileTaskStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FileTaskStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FileTaskStatus", str)
	}
	return nil
}

func (e FileTaskStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FileTaskType string

const (
	FileTaskTypeCopy FileTaskType = "COPY"
	FileTaskTypeMove FileTaskType = "MOVE"
)

var AllFileTaskType = []FileTaskType{
	FileTaskTypeCopy,
	FileTaskTypeMove,
}

func (e FileTaskType) IsValid() bool {
	switch e {
	case FileTaskTypeCopy, FileTaskTypeMove:
		return true
	}
	return false
}

func (e FileTaskType) String() string {
	return string(e)
}

func (e *FileTaskType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FileTaskType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FileTaskType", str)
	}
	return nil
}

func (e FileTaskType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MediaPlayMode string

const (
	MediaPlayModeRepeat    MediaPlayMode = "REPEAT"
	MediaPlayModeRepeatOne MediaPlayMode = "REPEAT_ONE"
	MediaPlayModeShuffle   MediaPlayMode = "SHUFFLE"
)

var AllMediaPlayMode = []MediaPlayMode{
	MediaPlayModeRepeat,
	MediaPlayModeRepeatOne,
	MediaPlayModeShuffle,
}

func (e MediaPlayMode) IsValid() bool {
	switch e {
	case MediaPlayModeRepeat, MediaPlayModeRepeatOne, MediaPlayModeShuffle:
		return true
	}
	return false
}

func (e MediaPlayMode) String() string {
	return string(e)
}

func (e *MediaPlayMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaPlayMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaPlayMode", str)
	}
	return nil
}

func (e MediaPlayMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SambaShareAuth string

const (
	SambaShareAuthGuest    SambaShareAuth = "GUEST"
	SambaShareAuthPassword SambaShareAuth = "PASSWORD"
)

var AllSambaShareAuth = []SambaShareAuth{
	SambaShareAuthGuest,
	SambaShareAuthPassword,
}

func (e SambaShareAuth) IsValid() bool {
	switch e {
	case SambaShareAuthGuest, SambaShareAuthPassword:
		return true
	}
	return false
}

func (e SambaShareAuth) String() string {
	return string(e)
}

func (e *SambaShareAuth) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SambaShareAuth(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SambaShareAuth", str)
	}
	return nil
}

func (e SambaShareAuth) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

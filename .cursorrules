# PlainNAS Development Rules

## Project Overview
PlainNAS is a Go-based NAS (Network Attached Storage) system with a Vue 3 web frontend. The backend provides API, file system, media, and watcher services, while the frontend (in `web/`) offers a modern UI for user interaction.

## Architecture & Key Components

### Backend (Go)
- **Entrypoint**: `main.go`, with commands in `cmd/` (e.g., `run.go`, `install.go`)
- **Services**: `internal/services/` (API, watcher), `internal/media/`, `internal/db/`, `internal/cache/`, `internal/config/`
- **GraphQL**: Defined in `internal/graph/schema.graphql`, resolvers in `internal/graph/schema.resolvers.go`, generated code in `internal/graph/generated/`
- **Config**: TOML files in `cmd/install/config.toml`
- **Systemd integration**: `cmd/install/plainnas.service`

### Frontend (Vue 3)
- **Location**: `web/`
- **Main entry**: `web/src/main.ts`, root component: `web/src/App.vue`
- **Components**: `web/src/components/`, assets: `web/src/assets/`
- **Build tools**: Vite (`vite.config.ts`), TypeScript (`tsconfig.json`)

## Developer Workflows

### Install & Initialize
```bash
sudo go run main.go install  # Run once to set up packages, DB, config
```

### Run (Dev)
```bash
sudo go run main.go run
```

### GraphQL Codegen
```bash
go env -w GOFLAGS=-mod=mod
go mod tidy
go generate ./internal/graph
```

### Production Build
```bash
go build
sudo mv ./plainnas /usr/local/bin/
sudo systemctl start plainnas
```

### Frontend Build
```bash
cd web/
npm install && npm run build
```

## Logging

Always use the project's logging system located at `internal/pkg/log/log.go`.

### Available Log Functions

```go
import "ismartcoding/plainnas/internal/pkg/log"

// Debug logging
log.Debug("message")
log.Debugf("format %s", value)

// Info logging
log.Info("message")
log.Infof("format %s", value)

// Error logging
log.Error(err)
log.Errorf("format %s", value)

// Trace logging
log.Trace("message")
log.Tracef("format %s", value)

// Panic logging
log.Panic(err)
log.Panicf("format %s", value)
```

### DO NOT Use

❌ `log.Printf()` from standard library
❌ `fmt.Println()` for logging
❌ Any other logging libraries

### Examples

```go
// ✅ Correct
log.Debugf("[FunctionName] operation completed: count=%d", count)
log.Infof("[ModuleName] started processing: id=%s", id)
log.Error(err)

// ❌ Wrong
log.Printf("operation completed: count=%d", count)
fmt.Println("started processing")
```

## Core Development Principles

### Code Quality
- Prioritize **simple, readable, minimal code** (less code is better)
- **Do not reduce features or logic**: behavior must remain correct
- **Do not regress performance**: avoid full scans, avoid N+1 patterns, preserve index-backed fast paths
- **Avoid duplication**: extract shared helpers instead of repeating parsing/filtering/iteration logic
- **Split oversized files**: keep files focused by responsibility (e.g., store vs indexes vs helpers)

### Compatibility & Migration
- **Avoid compatibility/migration/backfill code** unless explicitly requested
- Development workflow: it is acceptable to **delete the DB and rebuild**
- Avoid persistent index version machinery unless explicitly requested

### Documentation
- If logic/behavior changes, update relevant Markdown docs in `README.md` and/or `docs/`
- Keep docs in sync with code

## Platform Support (Linux Only)

PlainNAS is **Linux-only**. Design and implementation should assume Linux (systemd, `/proc`, `/sys`, `mount`, `lsblk`, etc.).

- Do **not** add Windows/macOS fallbacks, multi-platform abstractions, or non-Linux build stubs unless explicitly requested
- It is acceptable for non-Linux builds to fail; correctness on Linux takes priority

## Backend Patterns & Conventions

### Service Boundaries
- API, watcher, media, cache, DB, config are separated by directory
- Always check for service boundaries before making changes

### GraphQL Development
- Schema-driven development: Update `schema.graphql` and run codegen
- Keep `internal/graph/schema.resolvers.go` lightweight
- Resolvers should only validate/translate inputs and delegate to focused files (e.g. `internal/graph/*_api.go`)
- Do not put substantial business logic in `schema.resolvers.go`

### Example: Adding a GraphQL Field
1. Update `internal/graph/schema.graphql`
2. Run `go generate ./internal/graph`
3. Implement resolver in `internal/graph/schema.resolvers.go`

### Error Handling
Always handle errors appropriately:
```go
if err != nil {
    log.Error(err)
    return nil, err
}
```

### Root-Cause Fixes
- Prefer root-cause fixes over workaround logic
- Avoid extra guards/dedup that mask bugs
- If an invariant is broken, fix the source and let issues surface during development

## Frontend Patterns & Conventions

### Styling Rules
- **Avoid copy-pasting the same scoped CSS** across pages/components
- If a style pattern is used in more than one place, extract it into:
  - A shared stylesheet under `web/src/styles/`
  - A component-level style
  - A small reusable UI component
- Reuse via classes/components instead of duplicating blocks in each `.vue` file
- Keep `scoped` styles for truly view-specific tweaks only

### Forms & Validation (Vue + Vuetify)
- Prefer `vee-validate` `handleSubmit` + schema (see `SettingsBasicView`) for submit-time validation
- Show errors inline via each input's `error`/`error-text` gated by `dirty` and/or `submitAttempted`
- **Do not show extra error toasts** for client-side validation failures when the input already shows an inline error
- Reserve toasts for success and genuine server/network errors

### GraphQL (Vue Apollo)
- Prefer the existing wrappers `initMutation` / `initQuery` / `initLazyQuery` in `web/src/lib/api/*`
- Follow their patterns

#### Mutations (Callback-Driven)
```typescript
// ✅ Correct
const { mutate, loading, onDone, onError } = initMutation({ document: myMutation })

onDone((result) => {
  // handle success
})

onError((error) => {
  // handle error
})

// ❌ Wrong - do not use try/catch
try {
  await mutate()
} catch (error) {
  // GraphQL errors are not thrown as exceptions
}
```

#### Queries (Result-Driven)
```typescript
// ✅ Correct
const { loading, onResult } = initQuery({
  document: myQuery,
  handle: (data, error) => {
    if (error) {
      // handle error string
    } else {
      // handle data
    }
  }
})

// ❌ Wrong - do not use try/catch for GraphQL errors
```

### Yarn Commands
- Yarn v4+ (Berry) does **not** support `yarn -s` / `--silent`
- Run scripts as `yarn <script>` (e.g. `yarn typecheck`) without `-s`

## Testing

- Write unit tests for new functionality
- Use table-driven tests when appropriate
- Mock external dependencies

## Integration Points

- **API**: Go backend exposes GraphQL and REST endpoints (see `internal/services/api/`)
- **Watcher**: Monitors file changes (see `internal/services/watcher/`)
- **Media**: Handles media scanning/storage (see `internal/media/`)
- **Frontend-backend communication**: Via GraphQL and REST APIs

## External Dependencies

- Go modules (see `go.mod`)
- Node.js packages for frontend (see `web/package.json`)
- Systemd for service management

## For AI Agents

- Always check for service boundaries before making changes
- Use provided scripts and commands for setup/builds
- Reference key files for patterns (see above)
- Ask for clarification if workflow or integration is unclear
- Prioritize simple, readable, minimal code
- Avoid unnecessary abstractions and duplication
- Keep documentation in sync with code changes
